---
title: "Measuring the Middle"
author: "Alea Wilbur"
date: "Updated: `r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_depth: 2
    toc_float: yes
    theme: journal
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# `echo = FALSE` parameter is added to the code chunk to prevent printing of the R code in the output file.
library(shiny)
library(learnr)
library(stevedata)
library(tidyverse)
quartets <- as.data.frame(stevedata::quartets)
crash <- read_csv("~/GitHub/PPOL105/Traffic_Crashes_Cleaned.csv")

# quartets is now primed for all following chunks so code can be run in any order
```

```{r quartets tibble}
quartets
```

exercise.eval = true: chunk output is visible by default
exercise = true: allows for interactive fetures
```{r filter, exercise = TRUE, exercise.eval=TRUE}
# Look at only Group 1
filter(quartets, group == "Quartet 1")
```

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

# Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  
This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r quartets plot, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(1, 2, 5, 9), selected = 5),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 1, max = 8, value = 1, step = 1)
)

renderPlot({
  hist(quartets$group1, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "X Value", main = "Quartet 1")
  
  dens <- density(quartets$group, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

# Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

# Measuring the Center

Mean:
The average. Has a formula.
In Excel: =AVERAGE((CELL_1 + CELL_2 + CELL_3)/(Number_Of_Cells))

Calculate the mean
```{r mean, exercise = TRUE }
( 4 + 6 + 2 ) / 3
```


Median: 
Think of the thing between lanes in a road - the median. It is in the center. Equally distanced between both sides. 

Mode:




```{r quartets}
summary(quartets)
```

```{r}
quartets$x_cord <- quartets$x # R did not like the variables named x or y since those are also used in command. Renamed variables to avoid issues.
quartets$y_cord <- quartets$y
quartets_wide <-pivot_wider(quartets, names_from = group,
              values_from = c(x_cord, y_cord)) 

write.csv(quartets_wide, "quartets_wide.csv")

quartets_wide
```
```{r}
summary(quartets_wide)
```

If you include all the observations together:
```{r quartet graphs, echo=FALSE}
groupgraphs <- ggplot(quartets) +
  geom_point(aes(x, y, color=group), size = 1.5) +
  scale_x_continuous(breaks = seq(0,20,2)) +
  scale_y_continuous(breaks = seq(0,12,2)) +
  expand_limits(x = 0, y = 0) +
  labs(x = "X Value", y = "Y Value",
       title = "All Quartets" ) +
  theme_bw()
groupgraphs
```


Now split it into groups

```{r}
quartets %>% 
  group_by(group) %>% 
  summarize(averageX = mean(x), averageY=mean(y), varianceX =var(x), varianceY=var(y), medianX = median(x), medianY = median(y))
```

```{r}
Quartet1 <- quartets %>% filter(group=="Quartet 1")
plot(Quartet1$x, Quartet1$y)
```

```{r separate quartets}
Quartet2 <- quartets %>% filter(group=="Quartet 2")
Quartet3 <- quartets %>% filter(group=="Quartet 3")
Quartet4 <- quartets %>% filter(group=="Quartet 4")
```

```{r}
ggplot(quartets, aes(x=))
```

```{r}
reg = lm(y~x, data=quartets) # all x's and y's for all 4 Quartets

ggplot(data = quartets) + 
  geom_point(mapping = aes(x, y = y, color = group)) +
# color is used to indicate Quartet 1, 2, 3 or 4
    geom_abline(intercept=reg$coefficients[1], slope = reg$coefficients[2]) + 
  ylab("Y Value") +
  xlab("X Value") + 
  labs(title = "Quartets Scatterplot")
```


```{r Quartet facet wrap}
# facet wrap by Quartet

ggplot(data = quartets) + 
  geom_point(mapping = aes(x=x, y = y, color = group))+
  geom_abline(intercept=reg$coefficients[1], slope = reg$coefficients[2]) + 
 # annotate("text", x=12, y=0, label = lm(y ~ x, quartets), parse=TRUE)  + # doesn't work
  facet_wrap(~group) + # color is used to indicate Quartet 1, 2, 3 or 4
  ylab("Y Value") +
  xlab("X Value") + 
  labs(title = "Quartets Scatterplot")+
  theme(legend.position = "none") + 
  theme_bw()
```

Save your file!
```{r}
# write.csv(quartets, file = "quartets_long.csv")
```

```{r}
# plot of Chicago Crash Data
crash %>%
  filter(CRASH_DATE > 1/1/2020) %>%
  group_by(CRASH_HOUR) %>%
  summarize(n_crashes = n_distinct(UID)) %>%
  arrange((CRASH_HOUR)) %>%
  print() %>%
  ggplot(aes(x=CRASH_HOUR, y = n_crashes)) +
  geom_bar(stat = 'identity') + # tells ggplot that I am providing the y-value instead of counting the aggregate number of rows for each x value which is the default
  labs( title = "Crashes/Hour (Military Time)") + 
  xlab("Crashes Per Hour") +
  ylab("Number of Crashes during YEAR")
```
```{r}
median(crash$CRASH_HOUR) 
mean(crash$CRASH_HOUR)
```

# Measures of Dispersion

https://smac-group.github.io/ds/
```{r}
var()
sd()
min()
max()
range()
summary()

```

