---
title: "Measuring the Middle"
author: "Alea Wilbur"
date: "Updated: `r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_depth: 2
    toc_float: yes
    theme: journal
runtime: shiny_prerendered
---
Learning about centrality, means, medians, modes, and variance.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
# `echo = FALSE` parameter is added to the code chunk to prevent printing of the R code in the output file.
library(shiny)
library(learnr)
library(stevedata)
library(tidyverse)
library(kableExtra)
quartets <- as_tibble(stevedata::quartets)
crash <- read_csv("C:/Users/aleaw/OneDrive/Desktop/LessonPlans/PPOL105_Excel_Files/Traffic_Crashes_Cleaned.csv")

# quartets is now primed for all following chunks so code can be run in any order
```

Below is the quartets dataset in a long version.
```{r quartets long tibble, echo=FALSE}
quartets %>%
  kbl() %>%
  kable_styling()%>%
  scroll_box(width = "500px", height = "200px")
```

If you include all the observations together:
```{r quartet graphs, echo=FALSE}
groupgraphs <- ggplot(quartets) +
  geom_point(aes(x, y, color=group), size = 1.5) +
  scale_x_continuous(breaks = seq(0,20,2)) +
  scale_y_continuous(breaks = seq(0,12,2)) +
  expand_limits(x = 0, y = 0) +
  labs(x = "X Value", y = "Y Value",
       title = "All Quartets" ) +
  theme_bw()
groupgraphs
```

Here are the descriptive statistics for each group:
```{r, tidy=TRUE}
quartets %>% 
  group_by(group) %>% 
  summarize(averageX = mean(x), averageY=mean(y), varianceX =var(x), varianceY=var(y), medianX = median(x), medianY = median(y)) %>%
  kbl()%>%
  kable_paper("hover", full_width = T)
```

Compare it to the descriptive statistics for all the groups together:
```{r quartets}
summary(quartets) %>%
  kbl()%>%
  kable_styling()
```
Thoughts??



```{r filter, exercise = TRUE, exercise.eval=FALSE}
# Look at only one of the groups
filter(quartets, group == "Quartet 1")
```

# Inputs and Outputs

```{r, include=FALSE, echo=FALSE}
# You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  
# This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.
```


```{r quartets plot, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(1, 2, 5, 9), selected = 5),
  
  sliderInput("bw_adjust", label = "Binwidth adjustment:",
              min = 1, max = 8, value = 1, step = 1)
)

renderPlot({
  hist(quartets$x, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "X Value", main = "Quartets")
  
  # dens <- density(quartets$group, adjust = input$bw_adjust)
  # lines(dens, col = "blue")
})
```

# Measuring the Center

Mean:
The average. Has a formula.
In Excel: =AVERAGE((CELL_1 + CELL_2 + CELL_3)/(Number_Of_Cells))

Calculate the mean
```{r mean, exercise = TRUE }
( 4 + 6 + 2 ) / 3
```

Median: 
Think of the thing between lanes in a road - the median. It is in the center. Equally distanced between both sides. 


Mode:

Check out the histogram




```{r, include=FALSE, echo= FALSE}
# Delete this section?

# quartets$x_cord <- quartets$x # R did not like the variables named x or y since those are also used in command. Created new variables to avoid issues.
# quartets$y_cord <- quartets$y
# quartets_wide <-pivot_wider(quartets, names_from = group,
#               values_from = c(x_cord, y_cord)) 
# 
# # write.csv(quartets_wide, "quartets_wide.csv")
# 
# quartets_wide
# ```
# ```{r quartets wide tibble}
# quartetswide <- pivot_wider(quartets,  names_from = group, values_from = group)
# quartetswide %>% 
#   kbl() %>% 
#   kable_styling()
# ```

# ```{r}
# summary(quartets_wide)
```




Now split it into groups

```{r, tidy=TRUE}
quartets %>% 
  group_by(group) %>% 
  summarize(averageX = mean(x), averageY=mean(y), varianceX =var(x), varianceY=var(y), medianX = median(x), medianY = median(y))
```

```{r}
Quartet1 <- quartets %>% filter(group=="Quartet 1")
plot(Quartet1$x, Quartet1$y)
```

```{r separate quartets, echo = FALSE}
Quartet2 <- quartets %>% filter(group=="Quartet 2")
Quartet3 <- quartets %>% filter(group=="Quartet 3")
Quartet4 <- quartets %>% filter(group=="Quartet 4")
```

```{r, echo=FALSE}
# ggplot(quartets, aes(x=))
```

Slope of all quartet groups together:
```{r}
reg = lm(y~x, data=quartets) # all x's and y's for all 4 Quartets

ggplot(data = quartets) + 
  geom_point(mapping = aes(x, y = y, color = group)) +
# color is used to indicate Quartet 1, 2, 3 or 4
    geom_abline(intercept=reg$coefficients[1], slope = reg$coefficients[2]) + 
  ylab("Y Value") +
  xlab("X Value") + 
  labs(title = "Quartets Scatterplot")
```


```{r Quartet facet wrap}
# facet wrap by Quartet

ggplot(data = quartets) + 
  geom_point(mapping = aes(x=x, y = y, color = group))+
  geom_abline(intercept=reg$coefficients[1], slope = reg$coefficients[2]) + 
 # annotate("text", x=12, y=0, label = lm(y ~ x, quartets), parse=TRUE)  + # doesn't work
  facet_wrap(~group) + # color is used to indicate Quartet 1, 2, 3 or 4
  ylab("Y Value") +
  xlab("X Value") + 
  labs(title = "Quartets Scatterplot")+
  theme(legend.position = "none") + 
  theme_bw()
```

```{r}
# Save your file!

# write.csv(quartets, file = "quartets_long.csv")
```

# Chicago Crash Data
```{r}
# plot of Chicago Crash Data
crash %>%
  filter(CRASH_DATE > 1/1/2020) %>%
  group_by(CRASH_HOUR) %>%
  summarize(n_crashes = n_distinct(UID)) %>%
  arrange((CRASH_HOUR)) %>%
  print() %>%
  ggplot(aes(x=CRASH_HOUR, y = n_crashes)) +
  geom_bar(stat = 'identity') + # tells ggplot that I am providing the y-value instead of counting the aggregate number of rows for each x value which is the default
  labs( title = "Crashes/Hour (Military Time)") + 
  xlab("Crashes Per Hour") +
  ylab("Number of Crashes during YEAR")
```

```{r}
median(crash$CRASH_HOUR)
```


```{r}
mean(crash$CRASH_HOUR)
```

# Measures of Dispersion

https://smac-group.github.io/ds/
```{r}
# var()
# sd()
# min()
# max()
# range()
# summary()

```

